{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"泛型","slug":"泛型","date":"2019-09-12T09:47:36.000Z","updated":"2019-09-12T10:39:18.739Z","comments":true,"path":"2019/09/12/泛型/","link":"","permalink":"http://yoursite.com/2019/09/12/泛型/","excerpt":"","text":"java中的泛型1、概述泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？ 顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。 泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中， 操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。 2、一个栗子一个被举了无数次的例子： 12345678List arrayList = new ArrayList();arrayList.add(&quot;aaaa&quot;);arrayList.add(100);for(int i = 0; i&lt; arrayList.size();i++)&#123; String item = (String)arrayList.get(i); Log.d(&quot;泛型测试&quot;,&quot;item = &quot; + item);&#125; 毫无疑问，程序的运行结果会以崩溃结束： 1java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String ArrayList可以存放任意类型，例子中添加了一个String类型，添加了一个Integer类型，再使用时都以String的方式使用，因此程序崩溃了。为了解决类似这样的问题（在编译阶段就可以解决），泛型应运而生。 我们将第一行声明初始化list的代码更改一下，编译器会在编译阶段就能够帮我们发现类似这样的问题。 123List&lt;String&gt; arrayList = new ArrayList&lt;String&gt;();...//arrayList.add(100); 在编译阶段，编译器就会报错 3、特性泛型只在编译阶段有效。看下面的代码： 123456789List&lt;String&gt; stringArrayList = new ArrayList&lt;String&gt;();List&lt;Integer&gt; integerArrayList = new ArrayList&lt;Integer&gt;();Class classStringArrayList = stringArrayList.getClass();Class classIntegerArrayList = integerArrayList.getClass();if(classStringArrayList.equals(classIntegerArrayList))&#123; Log.d(&quot;泛型测试&quot;,&quot;类型相同&quot;);&#125; 输出结果：D/泛型测试: 类型相同。 通过上面的例子可以证明，在编译之后程序会采取去泛型化的措施。也就是说Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。 对此总结成一句话：泛型类型在逻辑上看可以看成是多个不同的类型，实际上都是相同的基本类型。 4、泛型的使用泛型有三种使用方式，分别为：泛型类、泛型接口、泛型方法 4.1泛型类泛型类型用于类的定义中，被称为泛型类。通过泛型可以完成对一组类的操作对外开放相同的接口。最典型的就是各种容器类，如：List、Set、Map。 泛型类的最基本写法（这么看可能会有点晕，会在下面的例子中详解）： 123456class 类名称 &lt;泛型标识：可以随便写任意标识号，标识指定的泛型的类型&gt;&#123; private 泛型标识 /*（成员变量类型）*/ var; ..... &#125;&#125; 一个最普通的泛型类： 1234567891011121314//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型//在实例化泛型类时，必须指定T的具体类型public class Generic&lt;T&gt;&#123; //key这个成员变量的类型为T,T的类型由外部指定 private T key; public Generic(T key) &#123; //泛型构造方法形参key的类型也为T，T的类型由外部指定 this.key = key; &#125; public T getKey()&#123; //泛型方法getKey的返回值类型为T，T的类型由外部指定 return key; &#125;&#125; 定义的泛型类，就一定要传入泛型类型实参么？并不是这样，在使用泛型的时候如果传入泛型实参，则会根据传入的泛型实参做相应的限制，此时泛型才会起到本应起到的限制作用。如果不传入泛型类型实参的话，在泛型类中使用泛型的方法或成员变量定义的类型可以为任何的类型。 1234567891011121314Generic generic = new Generic(&quot;111111&quot;);Generic generic1 = new Generic(4444);Generic generic2 = new Generic(55.55);Generic generic3 = new Generic(false);Log.d(&quot;泛型测试&quot;,&quot;key is &quot; + generic.getKey());Log.d(&quot;泛型测试&quot;,&quot;key is &quot; + generic1.getKey());Log.d(&quot;泛型测试&quot;,&quot;key is &quot; + generic2.getKey());Log.d(&quot;泛型测试&quot;,&quot;key is &quot; + generic3.getKey());D/泛型测试: key is 111111D/泛型测试: key is 4444D/泛型测试: key is 55.55D/泛型测试: key is false 注意： 泛型的类型参数只能是类类型，不能是简单类型。 不能对确切的泛型类型使用instanceof操作。如下面的操作是非法的，编译时会出错。if(ex_num instanceof Generic){ } 4.2泛型接口泛型接口与泛型类的定义及使用基本相同。泛型接口常被用在各种类的生产器中，可以看一个例子：1234//定义一个泛型接口public interface Generator&lt;T&gt; &#123; public T next();&#125; 4.3泛型方法在java中,泛型类的定义非常简单，但是泛型方法就比较复杂了。尤其是我们见到的大多数泛型类中的成员方法也都使用了泛型，有的甚至泛型类中也包含着泛型方法，这样在初学者中非常容易将泛型方法理解错了。泛型类，是在实例化类的时候指明泛型的具体类型；泛型方法，是在调用方法的时候指明泛型的具体类型 。 123456789101112131415/** * 泛型方法的基本介绍 * @param tClass 传入的泛型实参 * @return T 返回值为T类型 * 说明： * 1）public 与 返回值中间&lt;T&gt;非常重要，可以理解为声明此方法为泛型方法。 * 2）只有声明了&lt;T&gt;的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。 * 3）&lt;T&gt;表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。 * 4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。 */public &lt;T&gt; T genericMethod(Class&lt;T&gt; tClass)throws InstantiationException , IllegalAccessException&#123; T instance = tClass.newInstance(); return instance;&#125; 文章转载于https://www.cnblogs.com/coprince/p/8603492.html","categories":[],"tags":[],"keywords":[]},{"title":"Markdown语法","slug":"Markdown语法","date":"2019-09-06T09:16:29.000Z","updated":"2019-09-06T09:17:19.335Z","comments":true,"path":"2019/09/06/Markdown语法/","link":"","permalink":"http://yoursite.com/2019/09/06/Markdown语法/","excerpt":"","text":"Markdown语法简介1、字体设置：换行、斜体、粗体、删除线(1)使用反斜杠进行换行：”\\“(2)斜体：语法：”* *“、”_ _”示例1：这里是斜体示例2：_这里是斜体_(3)粗体：语法：”** **”示例：这里是粗体(4)斜体和粗体：语法：&quot;*** &quot;示例：这里是斜体并加粗***(5)删除线：语法：”~ ~“示例：这里是删除线\\ 2、分级标题（注意‘#’后面要加空格）(1)一级标题：语法：”# “ 这是一级标题(2)二级标题：语法：”## “ 这是二级标题(3)三级标题：语法：”### “ 这是三级标题(4)四级标题：语法：”#### “\\ 这是四级标题(5)五级标题：语法：”##### “\\ 这是五级标题(6)六级标题：语法：”###### “\\ 这是六级标题3、插入图片语法：”![图片描述](图片链接)”示例：”![百度](https://www.baidu.com/img/bd_logo1.png)&quot;\\ 4、链接1、点击打开百度：https://www.baidu.com/?tn=88093251_30_hao_pg 5、分割线语法：你可以在一行中用三个以上的星号(*)、底线(_)来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。语法示例：”*”、”—“、”___”示例1：”*“ 示例2：”_ _ _” 6、代码块对于程序员来说这个功能是必不可少的，插入程序代码的方式有两种，一种是利用缩进(tab), 另一种是利用英文“`”符号（一般在ESC键下方，和~同一个键）包裹代码。(1)代码块：缩进 4 个空格或是 1 个制表符。效果如下： public void static main(String[] args){ System.out.println(&quot;哈哈哈&quot;); }(2)多行代码块与语法高亮：在需要高亮的代码块的前一行及后一行使用三个单反引号“`”包裹，就可以了。示例如下: 123public void static main(String[] args)&#123; System.out.println(&quot;哈哈哈&quot;);&#125; 7、无序列表和有序列表7.1无序列表：语法：使用 *，+，- 表示无序列表。注意：符号后面一定要有一个空格，起到缩进的作用。\\ 列表文字1 列表文字1 列表文字1 列表文字1 列表文字1 列表文字1 列表文字1 列表文字1 列表文字17.2有序列表：语法：使用数字和一个英文句点表示有序列表。注意：英文句点后面一定要有一个空格，起到缩进的作用。 \\ 列表文字1 列表文字1 列表文字18、表格表格的基本写法很简单，就跟表格的形状很相似： 语法示例：12345学号|姓名|分数-|-|-1|小明|602|小红|613|小二|62 效果展示：学号|姓名|分数-|-|-1|小明|602|小红|613|小二|62 本文摘录自https://blog.csdn.net/u014061630/article/details/81359144#25-%E4%BB%A3%E7%A0%81%E5%9D%97","categories":[],"tags":[],"keywords":[]},{"title":"lambda","slug":"lambda","date":"2019-08-30T10:37:50.000Z","updated":"2019-08-30T11:43:09.907Z","comments":true,"path":"2019/08/30/lambda/","link":"","permalink":"http://yoursite.com/2019/08/30/lambda/","excerpt":"","text":"Java中的Lambda表达式1、概念：（1）Lambda表达式是Java SE 8中一个重要的新特性。lambda表达式允许你通过表达式来代替功能接口。 lambda表达式就和方法一样,它提供了一个正常的参数列表和一个使用这些参数的主体(body,可以是一个表达式或一个代码块)。（2）Lambda表达式增强了集合库。 Java SE 8添加了2个对集合数据进行批量操作的包: java.util.function 包以及java.util.stream 包。 流(stream)就如同迭代器(iterator),但附加了许多额外的功能。（3）在Lambda表达式中this是指外围实例，而匿名类中的this是指匿名类实例。2、流（stream）的特性：（1）stream不存储数据（2）stream不改变源数据，对stream的操作也不会影响到创建它的数组和集合（3）stream的延迟执行特性，延迟性是指当stream的终结操作执行的时候，前面的中间操作才执行。（4）对于stream的聚合、消费或收集操作只能进行一次，再次操作会报错。3、Lambda表达式的语法:基本语法: (parameters) -&gt; expression 或 (parameters) -&gt;{ statements; }4、示例： // Java 8之前： new Thread(new Runnable() { @Override public void run() { System.out.println(“Before Java8, too much code for too little to do”); } }).start(); //Java 8方式： new Thread( () -&gt; System.out.println(“In Java8, Lambda expression rocks !!”) ).start();","categories":[],"tags":[],"keywords":[]},{"title":"Vue","slug":"Vue","date":"2019-08-23T10:44:57.000Z","updated":"2019-08-23T11:17:28.041Z","comments":true,"path":"2019/08/23/Vue/","link":"","permalink":"http://yoursite.com/2019/08/23/Vue/","excerpt":"","text":"什么是VueVue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。 1、兼容性：Vue 不支持 IE8 及以下版本，因为 Vue 使用了 IE8 无法模拟的 ECMAScript 5 特性。但它支持所有兼容 ECMAScript 5 的浏览器。2、使用要点：在使用 Vue 时，我们推荐在你的浏览器上安装 Vue Devtools。它允许你在一个更友好的界面中审查和调试 Vue 应用。火狐浏览器可以正常安装，Chrome安装需要翻墙，插件地址:https://github.com/vuejs/vue-devtools3、版本区分：vue分为开发版和生产版，区别：开发板：包含完整的警告和调试模式生产版：删除了警告，33.30KB min+gzip4、vue的安装方式：（1）直接下载并用 script 标签引入，Vue 会被注册为一个全局变量。下载地址：https://cn.vuejs.org/v2/guide/installation.html#%E7%9B%B4%E6%8E%A5%E7%94%A8-lt-script-gt-%E5%BC%95%E5%85%A5（2）CDN:https://cn.vuejs.org/v2/guide/installation.html#CDN（3）NPM:https://cn.vuejs.org/v2/guide/installation.html#NPM 在用 Vue 构建大型应用时推荐使用 NPM 安装。NPM 能很好地和诸如 webpack 或 Browserify 模块打包器配合使用。同时 Vue 也提供配套工具来开发单文件组件。语法：$ npm install vue（4）命令行工具cli：https://cn.vuejs.org/v2/guide/installation.html#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-CLI","categories":[],"tags":[],"keywords":[]}]}